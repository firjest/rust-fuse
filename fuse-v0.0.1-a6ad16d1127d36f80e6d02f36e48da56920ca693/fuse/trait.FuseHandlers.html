<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `FuseHandlers` trait in crate `fuse`."><meta name="keywords" content="rust, rustlang, rust-lang, FuseHandlers"><title>fuse::FuseHandlers - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc trait"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../fuse/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Trait FuseHandlers</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#provided-methods">Provided Methods</a><div class="sidebar-links"><a href="#method.access">access</a><a href="#method.bmap">bmap</a><a href="#method.create">create</a><a href="#method.fallocate">fallocate</a><a href="#method.flush">flush</a><a href="#method.forget">forget</a><a href="#method.fsync">fsync</a><a href="#method.fsyncdir">fsyncdir</a><a href="#method.fuse_init">fuse_init</a><a href="#method.getattr">getattr</a><a href="#method.getlk">getlk</a><a href="#method.getxattr">getxattr</a><a href="#method.ioctl">ioctl</a><a href="#method.link">link</a><a href="#method.listxattr">listxattr</a><a href="#method.lookup">lookup</a><a href="#method.lseek">lseek</a><a href="#method.mkdir">mkdir</a><a href="#method.mknod">mknod</a><a href="#method.open">open</a><a href="#method.opendir">opendir</a><a href="#method.read">read</a><a href="#method.readdir">readdir</a><a href="#method.readlink">readlink</a><a href="#method.release">release</a><a href="#method.releasedir">releasedir</a><a href="#method.removexattr">removexattr</a><a href="#method.rename">rename</a><a href="#method.rmdir">rmdir</a><a href="#method.setattr">setattr</a><a href="#method.setlk">setlk</a><a href="#method.setxattr">setxattr</a><a href="#method.statfs">statfs</a><a href="#method.symlink">symlink</a><a href="#method.unlink">unlink</a><a href="#method.write">write</a></div><a class="sidebar-title" href="#implementors">Implementors</a></div><p class='location'><a href='index.html'>fuse</a></p><script>window.sidebarCurrent = {name: 'FuseHandlers', ty: 'trait', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/fuse/fuse_handlers.rs.html#29-812' title='goto source code'>[src]</a></span><span class='in-band'>Trait <a href='index.html'>fuse</a>::<wbr><a class="trait" href=''>FuseHandlers</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class='rust trait'>pub trait FuseHandlers {
    fn <a href='#method.fuse_init' class='fnname'>fuse_init</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.FuseInitRequest.html" title="struct fuse::protocol::FuseInitRequest">FuseInitRequest</a><br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="../fuse/protocol/struct.FuseInitResponse.html" title="struct fuse::protocol::FuseInitResponse">FuseInitResponse</a>&gt; { ... }
<div class='item-spacer'></div>    fn <a href='#method.access' class='fnname'>access</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.AccessRequest.html" title="struct fuse::protocol::AccessRequest">AccessRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.AccessResponse.html" title="struct fuse::protocol::AccessResponse">AccessResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.bmap' class='fnname'>bmap</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.BmapRequest.html" title="struct fuse::protocol::BmapRequest">BmapRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.BmapResponse.html" title="struct fuse::protocol::BmapResponse">BmapResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.create' class='fnname'>create</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.CreateRequest.html" title="struct fuse::protocol::CreateRequest">CreateRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.CreateResponse.html" title="struct fuse::protocol::CreateResponse">CreateResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.fallocate' class='fnname'>fallocate</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.FallocateRequest.html" title="struct fuse::protocol::FallocateRequest">FallocateRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.FallocateResponse.html" title="struct fuse::protocol::FallocateResponse">FallocateResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.flush' class='fnname'>flush</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.FlushRequest.html" title="struct fuse::protocol::FlushRequest">FlushRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.FlushResponse.html" title="struct fuse::protocol::FlushResponse">FlushResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.forget' class='fnname'>forget</a>(&amp;self, ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, request: &amp;<a class="struct" href="../fuse/protocol/struct.ForgetRequest.html" title="struct fuse::protocol::ForgetRequest">ForgetRequest</a>) { ... }
<div class='item-spacer'></div>    fn <a href='#method.fsync' class='fnname'>fsync</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.FsyncRequest.html" title="struct fuse::protocol::FsyncRequest">FsyncRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.FsyncResponse.html" title="struct fuse::protocol::FsyncResponse">FsyncResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.fsyncdir' class='fnname'>fsyncdir</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.FsyncdirRequest.html" title="struct fuse::protocol::FsyncdirRequest">FsyncdirRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.FsyncdirResponse.html" title="struct fuse::protocol::FsyncdirResponse">FsyncdirResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.getattr' class='fnname'>getattr</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.GetattrRequest.html" title="struct fuse::protocol::GetattrRequest">GetattrRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.GetattrResponse.html" title="struct fuse::protocol::GetattrResponse">GetattrResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.getlk' class='fnname'>getlk</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.GetlkRequest.html" title="struct fuse::protocol::GetlkRequest">GetlkRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.GetlkResponse.html" title="struct fuse::protocol::GetlkResponse">GetlkResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.getxattr' class='fnname'>getxattr</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.GetxattrRequest.html" title="struct fuse::protocol::GetxattrRequest">GetxattrRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.GetxattrResponse.html" title="struct fuse::protocol::GetxattrResponse">GetxattrResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.ioctl' class='fnname'>ioctl</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.IoctlRequest.html" title="struct fuse::protocol::IoctlRequest">IoctlRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.IoctlResponse.html" title="struct fuse::protocol::IoctlResponse">IoctlResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.link' class='fnname'>link</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.LinkRequest.html" title="struct fuse::protocol::LinkRequest">LinkRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.LinkResponse.html" title="struct fuse::protocol::LinkResponse">LinkResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.listxattr' class='fnname'>listxattr</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.ListxattrRequest.html" title="struct fuse::protocol::ListxattrRequest">ListxattrRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.ListxattrResponse.html" title="struct fuse::protocol::ListxattrResponse">ListxattrResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.lookup' class='fnname'>lookup</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.LookupRequest.html" title="struct fuse::protocol::LookupRequest">LookupRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.LookupResponse.html" title="struct fuse::protocol::LookupResponse">LookupResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.lseek' class='fnname'>lseek</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.LseekRequest.html" title="struct fuse::protocol::LseekRequest">LseekRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.LseekResponse.html" title="struct fuse::protocol::LseekResponse">LseekResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.mkdir' class='fnname'>mkdir</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.MkdirRequest.html" title="struct fuse::protocol::MkdirRequest">MkdirRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.MkdirResponse.html" title="struct fuse::protocol::MkdirResponse">MkdirResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.mknod' class='fnname'>mknod</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.MknodRequest.html" title="struct fuse::protocol::MknodRequest">MknodRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.MknodResponse.html" title="struct fuse::protocol::MknodResponse">MknodResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.open' class='fnname'>open</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.OpenRequest.html" title="struct fuse::protocol::OpenRequest">OpenRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.OpenResponse.html" title="struct fuse::protocol::OpenResponse">OpenResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.opendir' class='fnname'>opendir</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.OpendirRequest.html" title="struct fuse::protocol::OpendirRequest">OpendirRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.OpendirResponse.html" title="struct fuse::protocol::OpendirResponse">OpendirResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.read' class='fnname'>read</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.ReadRequest.html" title="struct fuse::protocol::ReadRequest">ReadRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.ReadResponse.html" title="struct fuse::protocol::ReadResponse">ReadResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.readdir' class='fnname'>readdir</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.ReaddirRequest.html" title="struct fuse::protocol::ReaddirRequest">ReaddirRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.ReaddirResponse.html" title="struct fuse::protocol::ReaddirResponse">ReaddirResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.readlink' class='fnname'>readlink</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.ReadlinkRequest.html" title="struct fuse::protocol::ReadlinkRequest">ReadlinkRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.ReadlinkResponse.html" title="struct fuse::protocol::ReadlinkResponse">ReadlinkResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.release' class='fnname'>release</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.ReleaseRequest.html" title="struct fuse::protocol::ReleaseRequest">ReleaseRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.ReleaseResponse.html" title="struct fuse::protocol::ReleaseResponse">ReleaseResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.releasedir' class='fnname'>releasedir</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.ReleasedirRequest.html" title="struct fuse::protocol::ReleasedirRequest">ReleasedirRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.ReleasedirResponse.html" title="struct fuse::protocol::ReleasedirResponse">ReleasedirResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.removexattr' class='fnname'>removexattr</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.RemovexattrRequest.html" title="struct fuse::protocol::RemovexattrRequest">RemovexattrRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.RemovexattrResponse.html" title="struct fuse::protocol::RemovexattrResponse">RemovexattrResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.rename' class='fnname'>rename</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.RenameRequest.html" title="struct fuse::protocol::RenameRequest">RenameRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.RenameResponse.html" title="struct fuse::protocol::RenameResponse">RenameResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.rmdir' class='fnname'>rmdir</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.RmdirRequest.html" title="struct fuse::protocol::RmdirRequest">RmdirRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.RmdirResponse.html" title="struct fuse::protocol::RmdirResponse">RmdirResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.setattr' class='fnname'>setattr</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.SetattrRequest.html" title="struct fuse::protocol::SetattrRequest">SetattrRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.SetattrResponse.html" title="struct fuse::protocol::SetattrResponse">SetattrResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.setlk' class='fnname'>setlk</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.SetlkRequest.html" title="struct fuse::protocol::SetlkRequest">SetlkRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.SetlkResponse.html" title="struct fuse::protocol::SetlkResponse">SetlkResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.setxattr' class='fnname'>setxattr</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.SetxattrRequest.html" title="struct fuse::protocol::SetxattrRequest">SetxattrRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.SetxattrResponse.html" title="struct fuse::protocol::SetxattrResponse">SetxattrResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.statfs' class='fnname'>statfs</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.StatfsRequest.html" title="struct fuse::protocol::StatfsRequest">StatfsRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.StatfsResponse.html" title="struct fuse::protocol::StatfsResponse">StatfsResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.symlink' class='fnname'>symlink</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.SymlinkRequest.html" title="struct fuse::protocol::SymlinkRequest">SymlinkRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.SymlinkResponse.html" title="struct fuse::protocol::SymlinkResponse">SymlinkResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.unlink' class='fnname'>unlink</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.UnlinkRequest.html" title="struct fuse::protocol::UnlinkRequest">UnlinkRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.UnlinkResponse.html" title="struct fuse::protocol::UnlinkResponse">UnlinkResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<div class='item-spacer'></div>    fn <a href='#method.write' class='fnname'>write</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.WriteRequest.html" title="struct fuse::protocol::WriteRequest">WriteRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.WriteResponse.html" title="struct fuse::protocol::WriteResponse">WriteResponse</a>&lt;'a&gt;&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
}</pre></div><div class='docblock'><p>User-provided handlers for FUSE operations.</p>
<p>Most FUSE handlers (with the exception of <a href="#method.fuse_init"><code>FuseHandlers::fuse_init</code></a>) are
asynchronous. These handlers receive a <a href="struct.ServerContext.html"><code>ServerContext</code></a> containing
information about the request itself, along with a <a href="struct.ServerResponseWriter.html"><code>ServerResponseWriter</code></a>
that must be used to send the response.</p>
<p>The default implementation for all async handlers is to respond with
error code <code>ENOSYS</code>.</p>
</div>
            <h2 id='provided-methods' class='small-section-header'>Provided methods<a href='#provided-methods' class='anchor'></a></h2><div class='methods'><h3 id='method.fuse_init' class='method'><code id='fuse_init.v'>fn <a href='#method.fuse_init' class='fnname'>fuse_init</a>(&amp;mut self, request: &amp;<a class="struct" href="../fuse/protocol/struct.FuseInitRequest.html" title="struct fuse::protocol::FuseInitRequest">FuseInitRequest</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="struct" href="../fuse/protocol/struct.FuseInitResponse.html" title="struct fuse::protocol::FuseInitResponse">FuseInitResponse</a>&gt;</code></h3><div class='docblock'><p>Initialize the FUSE connection parameters.</p>
<p>Most servers do not need to override this method.</p>
<p>The default implementation returns a response created by the helper
function <a href="protocol/struct.FuseInitResponse.html#method.for_request"><code>FuseInitResponse::for_request</code></a>, which is also a good starting
point for custom implementations.</p>
</div><h3 id='method.access' class='method'><code id='access.v'>fn <a href='#method.access' class='fnname'>access</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.AccessRequest.html" title="struct fuse::protocol::AccessRequest">AccessRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.AccessResponse.html" title="struct fuse::protocol::AccessResponse">AccessResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Check file access permissions</p>
<p>This will be called for the <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/access.html"><code>access(2)</code></a> and <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/chdir.html"><code>chdir(2)</code></a> system
calls.  If the <code>default_permissions</code> mount option is given,
this method is not called.</p>
<p>This method is not called under Linux kernel versions 2.4.x</p>
<p>If this request is answered with an error code of <code>ENOSYS</code>, this is
treated as a permanent success, i.e. this and all future <code>access()</code>
requests will succeed without being send to the filesystem process.</p>
</div><h3 id='method.bmap' class='method'><code id='bmap.v'>fn <a href='#method.bmap' class='fnname'>bmap</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.BmapRequest.html" title="struct fuse::protocol::BmapRequest">BmapRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.BmapResponse.html" title="struct fuse::protocol::BmapResponse">BmapResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Map block index within file to block index within device</p>
<p>Note: This makes sense only for block device backed filesystems
mounted with the <code>blkdev</code> option</p>
<p>If this request is answered with an error code of <code>ENOSYS</code>, this is
treated as a permanent failure, i.e. all future <code>bmap()</code> requests will
fail with the same error code without being send to the filesystem
process.</p>
</div><h3 id='method.create' class='method'><code id='create.v'>fn <a href='#method.create' class='fnname'>create</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.CreateRequest.html" title="struct fuse::protocol::CreateRequest">CreateRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.CreateResponse.html" title="struct fuse::protocol::CreateResponse">CreateResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Create and open a file</p>
<p>If the file does not exist, first create it with the specified
mode, and then open it.</p>
<p>See the description of <a href="#method.open"><code>FuseHandlers::open</code></a> for more
information.</p>
<p>If this method is not implemented or under Linux kernel
versions earlier than 2.6.15, the <a href="#method.mknod"><code>FuseHandlers::mknod</code></a> and
<a href="#method.open"><code>FuseHandlers::open</code></a> handlers will be called instead.</p>
<p>If this request is answered with an error code of <code>ENOSYS</code>, the handler
is treated as not implemented (i.e., for this and future requests the
<a href="#method.mknod"><code>FuseHandlers::mknod</code></a> and <a href="#method.open"><code>FuseHandlers::open</code></a> handlers will be
called instead).</p>
</div><h3 id='method.fallocate' class='method'><code id='fallocate.v'>fn <a href='#method.fallocate' class='fnname'>fallocate</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.FallocateRequest.html" title="struct fuse::protocol::FallocateRequest">FallocateRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.FallocateResponse.html" title="struct fuse::protocol::FallocateResponse">FallocateResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><h3 id='method.flush' class='method'><code id='flush.v'>fn <a href='#method.flush' class='fnname'>flush</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.FlushRequest.html" title="struct fuse::protocol::FlushRequest">FlushRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.FlushResponse.html" title="struct fuse::protocol::FlushResponse">FlushResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Flush method</p>
<p>This is called on each <code>close()</code> of the opened file.</p>
<p>Since file descriptors can be duplicated (<code>dup</code>, <code>dup2</code>, <code>fork</code>), for
one open call there may be many flush calls.</p>
<p>Filesystems shouldn't assume that flush will always be called
after some writes, or that if will be called at all.</p>
<p>fi-&gt;fh will contain the value set by the open method, or will
be undefined if the open method didn't set any value.</p>
<p>NOTE: the name of the method is misleading, since (unlike
fsync) the filesystem is not forced to flush pending writes.
One reason to flush data is if the filesystem wants to return
write errors during close.  However, such use is non-portable
because POSIX does not require <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/close.html">close</a> to wait for delayed I/O to
complete.</p>
<p>If the filesystem supports file locking operations (setlk,
getlk) it should remove all locks belonging to 'fi-&gt;owner'.</p>
<p>If this request is answered with an error code of ENOSYS,
this is treated as success and future calls to flush() will
succeed automatically without being send to the filesystem
process.</p>
</div><h3 id='method.forget' class='method'><code id='forget.v'>fn <a href='#method.forget' class='fnname'>forget</a>(&amp;self, ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, request: &amp;<a class="struct" href="../fuse/protocol/struct.ForgetRequest.html" title="struct fuse::protocol::ForgetRequest">ForgetRequest</a>)</code></h3><div class='docblock'><p>Forget about an inode</p>
<p>This function is called when the kernel removes an inode
from its internal caches.</p>
<p>The inode's lookup count increases by one for every call to
fuse_reply_entry and fuse_reply_create. The nlookup parameter
indicates by how much the lookup count should be decreased.</p>
<p>Inodes with a non-zero lookup count may receive request from
the kernel even after calls to unlink, rmdir or (when
overwriting an existing file) rename. Filesystems must handle
such requests properly and it is recommended to defer removal
of the inode until the lookup count reaches zero. Calls to
unlink, rmdir or rename will be followed closely by forget
unless the file or directory is open, in which case the
kernel issues forget only after the release or releasedir
calls.</p>
<p>Note that if a file system will be exported over NFS the
inodes lifetime must extend even beyond forget. See the
generation field in struct fuse_entry_param above.</p>
<p>On unmount the lookup count for all inodes implicitly drops
to zero. It is not guaranteed that the file system will
receive corresponding forget messages for the affected
inodes.</p>
</div><h3 id='method.fsync' class='method'><code id='fsync.v'>fn <a href='#method.fsync' class='fnname'>fsync</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.FsyncRequest.html" title="struct fuse::protocol::FsyncRequest">FsyncRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.FsyncResponse.html" title="struct fuse::protocol::FsyncResponse">FsyncResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Synchronize file contents</p>
<p>If the datasync parameter is non-zero, then only the user data
should be flushed, not the meta data.</p>
<p>If this request is answered with an error code of ENOSYS,
this is treated as success and future calls to fsync() will
succeed automatically without being send to the filesystem
process.</p>
</div><h3 id='method.fsyncdir' class='method'><code id='fsyncdir.v'>fn <a href='#method.fsyncdir' class='fnname'>fsyncdir</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.FsyncdirRequest.html" title="struct fuse::protocol::FsyncdirRequest">FsyncdirRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.FsyncdirResponse.html" title="struct fuse::protocol::FsyncdirResponse">FsyncdirResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Synchronize directory contents</p>
<p>If the datasync parameter is non-zero, then only the directory
contents should be flushed, not the meta data.</p>
<p>fi-&gt;fh will contain the value set by the opendir method, or
will be undefined if the opendir method didn't set any value.</p>
<p>If this request is answered with an error code of ENOSYS,
this is treated as success and future calls to fsyncdir() will
succeed automatically without being send to the filesystem
process.</p>
</div><h3 id='method.getattr' class='method'><code id='getattr.v'>fn <a href='#method.getattr' class='fnname'>getattr</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.GetattrRequest.html" title="struct fuse::protocol::GetattrRequest">GetattrRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.GetattrResponse.html" title="struct fuse::protocol::GetattrResponse">GetattrResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Get file attributes.</p>
<p>If writeback caching is enabled, the kernel may have a
better idea of a file's length than the FUSE file system
(eg if there has been a write that extended the file size,
but that has not yet been passed to the filesystem.</p>
<p>In this case, the <a href="protocol/struct.NodeAttr.html#method.size"><code>NodeAttr::size</code></a> value provided by the file system
will be ignored.</p>
</div><h3 id='method.getlk' class='method'><code id='getlk.v'>fn <a href='#method.getlk' class='fnname'>getlk</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.GetlkRequest.html" title="struct fuse::protocol::GetlkRequest">GetlkRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.GetlkResponse.html" title="struct fuse::protocol::GetlkResponse">GetlkResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Test for a POSIX file lock</p>
</div><h3 id='method.getxattr' class='method'><code id='getxattr.v'>fn <a href='#method.getxattr' class='fnname'>getxattr</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.GetxattrRequest.html" title="struct fuse::protocol::GetxattrRequest">GetxattrRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.GetxattrResponse.html" title="struct fuse::protocol::GetxattrResponse">GetxattrResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Get an extended attribute</p>
<p>If size is zero, the size of the value should be sent with
fuse_reply_xattr.</p>
<p>If the size is non-zero, and the value fits in the buffer, the
value should be sent with fuse_reply_buf.</p>
<p>If the size is too small for the value, the ERANGE error should
be sent.</p>
<p>If this request is answered with an error code of ENOSYS, this is
treated as a permanent failure with error code EOPNOTSUPP, i.e. all
future getxattr() requests will fail with EOPNOTSUPP without being
send to the filesystem process.</p>
</div><h3 id='method.ioctl' class='method'><code id='ioctl.v'>fn <a href='#method.ioctl' class='fnname'>ioctl</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.IoctlRequest.html" title="struct fuse::protocol::IoctlRequest">IoctlRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.IoctlResponse.html" title="struct fuse::protocol::IoctlResponse">IoctlResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Ioctl</p>
<p>Note: For unrestricted ioctls (not allowed for FUSE
servers), data in and out areas can be discovered by giving
iovs and setting FUSE_IOCTL_RETRY in <em>flags</em>.  For
restricted ioctls, kernel prepares in/out data area
according to the information encoded in cmd.</p>
<p>Valid replies:
fuse_reply_ioctl_retry
fuse_reply_ioctl
fuse_reply_ioctl_iov
fuse_reply_err</p>
<p>@param req request handle
@param ino the inode number
@param cmd ioctl command
@param arg ioctl argument
@param fi file information
@param flags for FUSE_IOCTL_* flags
@param in_buf data fetched from the caller
@param in_bufsz number of fetched bytes
@param out_bufsz maximum size of output data</p>
<p>Note : the unsigned long request submitted by the application
is truncated to 32 bits.</p>
</div><h3 id='method.link' class='method'><code id='link.v'>fn <a href='#method.link' class='fnname'>link</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.LinkRequest.html" title="struct fuse::protocol::LinkRequest">LinkRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.LinkResponse.html" title="struct fuse::protocol::LinkResponse">LinkResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Create a hard link</p>
</div><h3 id='method.listxattr' class='method'><code id='listxattr.v'>fn <a href='#method.listxattr' class='fnname'>listxattr</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.ListxattrRequest.html" title="struct fuse::protocol::ListxattrRequest">ListxattrRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.ListxattrResponse.html" title="struct fuse::protocol::ListxattrResponse">ListxattrResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>List extended attribute names</p>
<p>If size is zero, the total size of the attribute list should be
sent with fuse_reply_xattr.</p>
<p>If the size is non-zero, and the null character separated
attribute list fits in the buffer, the list should be sent with
fuse_reply_buf.</p>
<p>If the size is too small for the list, the ERANGE error should
be sent.</p>
<p>If this request is answered with an error code of ENOSYS, this is
treated as a permanent failure with error code EOPNOTSUPP, i.e. all
future listxattr() requests will fail with EOPNOTSUPP without being
send to the filesystem process.</p>
</div><h3 id='method.lookup' class='method'><code id='lookup.v'>fn <a href='#method.lookup' class='fnname'>lookup</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.LookupRequest.html" title="struct fuse::protocol::LookupRequest">LookupRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.LookupResponse.html" title="struct fuse::protocol::LookupResponse">LookupResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Look up a directory entry by name and get its attributes.</p>
</div><h3 id='method.lseek' class='method'><code id='lseek.v'>fn <a href='#method.lseek' class='fnname'>lseek</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.LseekRequest.html" title="struct fuse::protocol::LseekRequest">LseekRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.LseekResponse.html" title="struct fuse::protocol::LseekResponse">LseekResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Find next data or hole after the specified offset</p>
<p>If this request is answered with an error code of ENOSYS, this is
treated as a permanent failure, i.e. all future lseek() requests will
fail with the same error code without being send to the filesystem
process.</p>
</div><h3 id='method.mkdir' class='method'><code id='mkdir.v'>fn <a href='#method.mkdir' class='fnname'>mkdir</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.MkdirRequest.html" title="struct fuse::protocol::MkdirRequest">MkdirRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.MkdirResponse.html" title="struct fuse::protocol::MkdirResponse">MkdirResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Create a directory</p>
</div><h3 id='method.mknod' class='method'><code id='mknod.v'>fn <a href='#method.mknod' class='fnname'>mknod</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.MknodRequest.html" title="struct fuse::protocol::MknodRequest">MknodRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.MknodResponse.html" title="struct fuse::protocol::MknodResponse">MknodResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Create file node</p>
<p>Create a regular file, character device, block device, fifo or
socket node.</p>
</div><h3 id='method.open' class='method'><code id='open.v'>fn <a href='#method.open' class='fnname'>open</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.OpenRequest.html" title="struct fuse::protocol::OpenRequest">OpenRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.OpenResponse.html" title="struct fuse::protocol::OpenResponse">OpenResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Open a file</p>
<p>Open flags are available in fi-&gt;flags. The following rules
apply.</p>
<ul>
<li>
<p>Creation (O_CREAT, O_EXCL, O_NOCTTY) flags will be
filtered out / handled by the kernel.</p>
</li>
<li>
<p>Access modes (O_RDONLY, O_WRONLY, O_RDWR) should be used
by the filesystem to check if the operation is
permitted.  If the <code>-o default_permissions</code> mount
option is given, this check is already done by the
kernel before calling open() and may thus be omitted by
the filesystem.</p>
</li>
<li>
<p>When writeback caching is enabled, the kernel may send
read requests even for files opened with O_WRONLY. The
filesystem should be prepared to handle this.</p>
</li>
<li>
<p>When writeback caching is disabled, the filesystem is
expected to properly handle the O_APPEND flag and ensure
that each write is appending to the end of the file.</p>
</li>
<li>
<p>When writeback caching is enabled, the kernel will
handle O_APPEND. However, unless all changes to the file
come through the kernel this will not work reliably. The
filesystem should thus either ignore the O_APPEND flag
(and let the kernel handle it), or return an error
(indicating that reliably O_APPEND is not available).</p>
</li>
</ul>
<p>Filesystem may store an arbitrary file handle (pointer,
index, etc) in fi-&gt;fh, and use this in other all other file
operations (read, write, flush, release, fsync).</p>
<p>Filesystem may also implement stateless file I/O and not store
anything in fi-&gt;fh.</p>
<p>There are also some flags (direct_io, keep_cache) which the
filesystem may set in fi, to change the way the file is opened.
See fuse_file_info structure in &lt;fuse_common.h&gt; for more details.</p>
<p>If this request is answered with an error code of ENOSYS
and FUSE_CAP_NO_OPEN_SUPPORT is set in
<code>fuse_conn_info.capable</code>, this is treated as success and
future calls to open and release will also succeed without being
sent to the filesystem process.</p>
</div><h3 id='method.opendir' class='method'><code id='opendir.v'>fn <a href='#method.opendir' class='fnname'>opendir</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.OpendirRequest.html" title="struct fuse::protocol::OpendirRequest">OpendirRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.OpendirResponse.html" title="struct fuse::protocol::OpendirResponse">OpendirResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Open a directory</p>
<p>Filesystem may store an arbitrary file handle (pointer, index,
etc) in fi-&gt;fh, and use this in other all other directory
stream operations (readdir, releasedir, fsyncdir).</p>
<p>If this request is answered with an error code of ENOSYS and
FUSE_CAP_NO_OPENDIR_SUPPORT is set in <code>fuse_conn_info.capable</code>,
this is treated as success and future calls to opendir and
releasedir will also succeed without being sent to the filesystem
process. In addition, the kernel will cache readdir results
as if opendir returned FOPEN_KEEP_CACHE | FOPEN_CACHE_DIR.</p>
</div><h3 id='method.read' class='method'><code id='read.v'>fn <a href='#method.read' class='fnname'>read</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.ReadRequest.html" title="struct fuse::protocol::ReadRequest">ReadRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.ReadResponse.html" title="struct fuse::protocol::ReadResponse">ReadResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Read data</p>
<p>Read should send exactly the number of bytes requested except
on EOF or error, otherwise the rest of the data will be
substituted with zeroes.  An exception to this is when the file
has been opened in 'direct_io' mode, in which case the return
value of the read system call will reflect the return value of
this operation.</p>
<p>fi-&gt;fh will contain the value set by the open method, or will
be undefined if the open method didn't set any value.</p>
</div><h3 id='method.readdir' class='method'><code id='readdir.v'>fn <a href='#method.readdir' class='fnname'>readdir</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.ReaddirRequest.html" title="struct fuse::protocol::ReaddirRequest">ReaddirRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.ReaddirResponse.html" title="struct fuse::protocol::ReaddirResponse">ReaddirResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Read directory</p>
<p>Send a buffer filled using fuse_add_direntry(), with size not
exceeding the requested size.  Send an empty buffer on end of
stream.</p>
<p>fi-&gt;fh will contain the value set by the opendir method, or
will be undefined if the opendir method didn't set any value.</p>
<p>Returning a directory entry from readdir() does not affect
its lookup count.</p>
<p>If off_t is non-zero, then it will correspond to one of the off_t
values that was previously returned by readdir() for the same
directory handle. In this case, readdir() should skip over entries
coming before the position defined by the off_t value. If entries
are added or removed while the directory handle is open, they filesystem
may still include the entries that have been removed, and may not
report the entries that have been created. However, addition or
removal of entries must never cause readdir() to skip over unrelated
entries or to report them more than once. This means
that off_t can not be a simple index that enumerates the entries
that have been returned but must contain sufficient information to
uniquely determine the next directory entry to return even when the
set of entries is changing.</p>
<p>The function does not have to report the '.' and '..'
entries, but is allowed to do so. Note that, if readdir does
not return '.' or '..', they will not be implicitly returned,
and this behavior is observable by the caller.</p>
</div><h3 id='method.readlink' class='method'><code id='readlink.v'>fn <a href='#method.readlink' class='fnname'>readlink</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.ReadlinkRequest.html" title="struct fuse::protocol::ReadlinkRequest">ReadlinkRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.ReadlinkResponse.html" title="struct fuse::protocol::ReadlinkResponse">ReadlinkResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Read symbolic link</p>
</div><h3 id='method.release' class='method'><code id='release.v'>fn <a href='#method.release' class='fnname'>release</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.ReleaseRequest.html" title="struct fuse::protocol::ReleaseRequest">ReleaseRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.ReleaseResponse.html" title="struct fuse::protocol::ReleaseResponse">ReleaseResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Release an open file</p>
<p>Release is called when there are no more references to an open
file: all file descriptors are closed and all memory mappings
are unmapped.</p>
<p>For every open call there will be exactly one release call (unless
the filesystem is force-unmounted).</p>
<p>The filesystem may reply with an error, but error values are
not returned to close() or munmap() which triggered the
release.</p>
<p>fi-&gt;fh will contain the value set by the open method, or will
be undefined if the open method didn't set any value.
fi-&gt;flags will contain the same flags as for open.</p>
</div><h3 id='method.releasedir' class='method'><code id='releasedir.v'>fn <a href='#method.releasedir' class='fnname'>releasedir</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.ReleasedirRequest.html" title="struct fuse::protocol::ReleasedirRequest">ReleasedirRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.ReleasedirResponse.html" title="struct fuse::protocol::ReleasedirResponse">ReleasedirResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Release an open directory</p>
<p>For every opendir call there will be exactly one releasedir
call (unless the filesystem is force-unmounted).</p>
<p>fi-&gt;fh will contain the value set by the opendir method, or
will be undefined if the opendir method didn't set any value.</p>
</div><h3 id='method.removexattr' class='method'><code id='removexattr.v'>fn <a href='#method.removexattr' class='fnname'>removexattr</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.RemovexattrRequest.html" title="struct fuse::protocol::RemovexattrRequest">RemovexattrRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.RemovexattrResponse.html" title="struct fuse::protocol::RemovexattrResponse">RemovexattrResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Remove an extended attribute</p>
<p>If this request is answered with an error code of ENOSYS, this is
treated as a permanent failure with error code EOPNOTSUPP, i.e. all
future removexattr() requests will fail with EOPNOTSUPP without being
send to the filesystem process.</p>
</div><h3 id='method.rename' class='method'><code id='rename.v'>fn <a href='#method.rename' class='fnname'>rename</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.RenameRequest.html" title="struct fuse::protocol::RenameRequest">RenameRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.RenameResponse.html" title="struct fuse::protocol::RenameResponse">RenameResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Rename a file</p>
<p>If the target exists it should be atomically replaced. If
the target's inode's lookup count is non-zero, the file
system is expected to postpone any removal of the inode
until the lookup count reaches zero (see description of the
forget function).</p>
<p>If this request is answered with an error code of ENOSYS, this is
treated as a permanent failure with error code EINVAL, i.e. all
future bmap requests will fail with EINVAL without being
send to the filesystem process.</p>
<p><em>flags</em> may be <code>RENAME_EXCHANGE</code> or <code>RENAME_NOREPLACE</code>. If
RENAME_NOREPLACE is specified, the filesystem must not
overwrite <em>newname</em> if it exists and return an error
instead. If <code>RENAME_EXCHANGE</code> is specified, the filesystem
must atomically exchange the two files, i.e. both must
exist and neither may be deleted.</p>
</div><h3 id='method.rmdir' class='method'><code id='rmdir.v'>fn <a href='#method.rmdir' class='fnname'>rmdir</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.RmdirRequest.html" title="struct fuse::protocol::RmdirRequest">RmdirRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.RmdirResponse.html" title="struct fuse::protocol::RmdirResponse">RmdirResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Remove a directory</p>
<p>If the directory's inode's lookup count is non-zero, the
file system is expected to postpone any removal of the
inode until the lookup count reaches zero (see description
of the forget function).</p>
</div><h3 id='method.setattr' class='method'><code id='setattr.v'>fn <a href='#method.setattr' class='fnname'>setattr</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.SetattrRequest.html" title="struct fuse::protocol::SetattrRequest">SetattrRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.SetattrResponse.html" title="struct fuse::protocol::SetattrResponse">SetattrResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Set file attributes</p>
<p>In the 'attr' argument only members indicated by the 'to_set'
bitmask contain valid values.  Other members contain undefined
values.</p>
<p>Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is
expected to reset the setuid and setgid bits if the file
size or owner is being changed.</p>
<p>If the setattr was invoked from the ftruncate() system call
under Linux kernel versions 2.6.15 or later, the fi-&gt;fh will
contain the value set by the open method or will be undefined
if the open method didn't set any value.  Otherwise (not
ftruncate call, or kernel version earlier than 2.6.15) the fi
parameter will be NULL.</p>
</div><h3 id='method.setlk' class='method'><code id='setlk.v'>fn <a href='#method.setlk' class='fnname'>setlk</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.SetlkRequest.html" title="struct fuse::protocol::SetlkRequest">SetlkRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.SetlkResponse.html" title="struct fuse::protocol::SetlkResponse">SetlkResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Acquire, modify or release a POSIX file lock</p>
<p>For POSIX threads (NPTL) there's a 1-1 relation between pid and
owner, but otherwise this is not always the case.  For checking
lock ownership, 'fi-&gt;owner' must be used.  The l_pid field in
'struct flock' should only be used to fill in this field in
getlk().</p>
<p>Note: if the locking methods are not implemented, the kernel
will still allow file locking to work locally.  Hence these are
only interesting for network filesystems and similar.</p>
</div><h3 id='method.setxattr' class='method'><code id='setxattr.v'>fn <a href='#method.setxattr' class='fnname'>setxattr</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.SetxattrRequest.html" title="struct fuse::protocol::SetxattrRequest">SetxattrRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.SetxattrResponse.html" title="struct fuse::protocol::SetxattrResponse">SetxattrResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Set an extended attribute</p>
<p>If this request is answered with an error code of ENOSYS, this is
treated as a permanent failure with error code EOPNOTSUPP, i.e. all
future setxattr() requests will fail with EOPNOTSUPP without being
send to the filesystem process.</p>
</div><h3 id='method.statfs' class='method'><code id='statfs.v'>fn <a href='#method.statfs' class='fnname'>statfs</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.StatfsRequest.html" title="struct fuse::protocol::StatfsRequest">StatfsRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.StatfsResponse.html" title="struct fuse::protocol::StatfsResponse">StatfsResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Get file system statistics</p>
</div><h3 id='method.symlink' class='method'><code id='symlink.v'>fn <a href='#method.symlink' class='fnname'>symlink</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.SymlinkRequest.html" title="struct fuse::protocol::SymlinkRequest">SymlinkRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.SymlinkResponse.html" title="struct fuse::protocol::SymlinkResponse">SymlinkResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Create a symbolic link</p>
</div><h3 id='method.unlink' class='method'><code id='unlink.v'>fn <a href='#method.unlink' class='fnname'>unlink</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.UnlinkRequest.html" title="struct fuse::protocol::UnlinkRequest">UnlinkRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.UnlinkResponse.html" title="struct fuse::protocol::UnlinkResponse">UnlinkResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Remove a file</p>
<p>If the file's inode's lookup count is non-zero, the file
system is expected to postpone any removal of the inode
until the lookup count reaches zero (see description of the
forget function).</p>
</div><h3 id='method.write' class='method'><code id='write.v'>fn <a href='#method.write' class='fnname'>write</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;ctx: <a class="struct" href="../fuse/struct.ServerContext.html" title="struct fuse::ServerContext">ServerContext</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;request: &amp;<a class="struct" href="../fuse/protocol/struct.WriteRequest.html" title="struct fuse::protocol::WriteRequest">WriteRequest</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;respond: impl for&lt;'a&gt; <a class="trait" href="../fuse/trait.RespondOnce.html" title="trait fuse::RespondOnce">RespondOnce</a>&lt;<a class="struct" href="../fuse/protocol/struct.WriteResponse.html" title="struct fuse::protocol::WriteResponse">WriteResponse</a>&lt;'a&gt;&gt;<br>)</code></h3><div class='docblock'><p>Write data</p>
<p>Write should return exactly the number of bytes requested
except on error.  An exception to this is when the file has
been opened in 'direct_io' mode, in which case the return value
of the write system call will reflect the return value of this
operation.</p>
<p>Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is
expected to reset the setuid and setgid bits.</p>
<p>fi-&gt;fh will contain the value set by the open method, or will
be undefined if the open method didn't set any value.</p>
</div></div><span class='loading-content'>Loading content...</span>
            <h2 id='implementors' class='small-section-header'>Implementors<a href='#implementors' class='anchor'></a></h2><div class='item-list' id='implementors-list'></div><span class='loading-content'>Loading content...</span><script type="text/javascript" src="../implementors/fuse/trait.FuseHandlers.js" async></script></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "fuse";</script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>